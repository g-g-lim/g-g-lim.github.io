---
layout: page
title: "/1차캐시"
permalink: /1차캐시
---

# 1차캐시

<img src="/assets/images/programmers/1차캐시.png" width="100%" alt="1차캐시" />
<img src="/assets/images/programmers/1차캐시-1.png" width="100%" alt="1차캐시" />
<img src="/assets/images/programmers/1차캐시-2.png" width="100%" alt="1차캐시" />

```javascript
class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.cache = new Map();
        this.head = new Node(null, null);
        this.tail = new Node(null, null);
        this.head.next = this.tail;
        this.tail.prev = this.head;
        this.size = 0;
        this.total = 0;
    }

    get(key) {
        const node = this.cache.get(key);

        if (!node) { // miss
            this.put(key, key);
            this.total += 5;
            return this.total;
        } else { // hit
            this.moveToTail(node);
            this.total += 1;
            return this.total;
        }
    }

    put(key, value) {
        if (this.capacity === 0) return;

        // 이미 존재하는 경우 업데이트
        if (this.cache.has(key)) {
            const node = this.cache.get(key);
            node.value = value;
            this.moveToTail(node);
            return;
        }

        // 캐시가 가득 찬 경우 가장 오래된 항목 제거
        if (this.size >= this.capacity) {
            const oldest = this.head.next;
            this.removeNode(oldest);
            this.cache.delete(oldest.key);
            this.size--;
        }

        // 새 노드 추가
        const newNode = new Node(key, value);
        this.cache.set(key, newNode);
        this.addToTail(newNode);
        this.size++;
    }

    // 노드를 맨 뒤로 이동 (가장 최근 사용)
    moveToTail(node) {
        this.removeNode(node);
        this.addToTail(node);
    }

    // 노드 제거
    removeNode(node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    // 맨 뒤에 노드 추가
    addToTail(node) {
        node.prev = this.tail.prev;
        node.next = this.tail;
        this.tail.prev.next = node;
        this.tail.prev = node;
    }

    get isFull() {
        return this.size >= this.capacity;
    }
}

class Node {
    constructor(key, value) {
        this.key = key;
        this.value = value;
        this.prev = null;
        this.next = null;
    }
}

function solution(cacheSize, cities) {
    const cache = new LRUCache(cacheSize);
    for (const city of cities) {
        cache.get(city.toLowerCase());
    }
    return cache.total;
}
```