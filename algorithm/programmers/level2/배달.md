---
layout: page
title: "/배달"
permalink: /배달
---

# 배달

<img src="/assets/images/programmers/배달.png" width="100%" alt="배달" />
<img src="/assets/images/programmers/배달-1.png" width="100%" alt="배달" />
<img src="/assets/images/programmers/배달-2.png" width="100%" alt="배달" />

```javascript
function solution(N, road, K) {
    let graph = {}

    for (const r of road) {
        const [from, to, cost] = r;
        if (graph[from] === undefined) {
            graph[from] = {[to]: cost}
        } else {
            map = graph[from];
            if (map[to] === undefined) {
                graph[from][to] = cost;
            } else {
                if (graph[from][to] > cost) {
                    graph[from][to] = cost;
                } 
            }
        }
        if (graph[to] === undefined) {
            graph[to] = {[from]: cost}
        } else {
            map = graph[to];
            if (map[from] === undefined) {
                graph[to][from] = cost;
            } else {
                if (graph[to][from] > cost) {
                    graph[to][from] = cost;
                }
            }
        }
    }

    return dijkstra(N, graph, K);
}

function dijkstra(N, graph, K){
    const costs = Array(N).fill(Infinity);
    costs[0] = 0;
    const visited = new Set();
    const minHeap = new MinHeap();
    minHeap.push([1, 0])

    while (!minHeap.isEmpty()) {
        const [node, sum] = minHeap.pop()
        if (visited.has(node)) {
            continue;
        }

        visited.add(node);

        for (const [to, cost] of Object.entries(graph[node])) {
            if (costs[+to - 1] > sum + cost) {
                costs[+to - 1] = sum + cost;
                minHeap.push([+to, costs[+to - 1]]);
            }
        }
    }

    const result = [];
    for (let i = 0; i < costs.length; i++){
        if (K >= costs[i]) {
            result.push(i+1);
        }
    }
    return result;
}

// MinHeap 클래스 구현
class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    // 힙에 요소 추가
    push(element) {
        this.heap.push(element);
        this.bubbleUp();
    }
    
    // 최소값 제거 및 반환
    pop() {
        if (this.isEmpty()) return null;
        
        const min = this.heap[0];
        const last = this.heap.pop();
        
        if (this.heap.length > 0) {
            this.heap[0] = last;
            this.bubbleDown();
        }
        
        return min;
    }
    
    // 최소값 확인 (제거하지 않음)
    peek() {
        return this.isEmpty() ? null : this.heap[0];
    }
    
    // 힙이 비어있는지 확인
    isEmpty() {
        return this.heap.length === 0;
    }
    
    // 힙의 크기 반환
    size() {
        return this.heap.length;
    }
    
    // 위로 거품 올리기 (새로 추가된 요소를 적절한 위치로)
    bubbleUp() {
        let index = this.heap.length - 1;
        
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            
            if (this.heap[parentIndex][1] <= this.heap[index][1]) {
                break;
            }
            
            // 부모와 자식 교환
            [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];
            index = parentIndex;
        }
    }
    
    // 아래로 거품 내리기 (루트를 적절한 위치로)
    bubbleDown() {
        let index = 0;
        
        while (true) {
            let smallest = index;
            const leftChild = 2 * index + 1;
            const rightChild = 2 * index + 2;
            
            // 왼쪽 자식이 더 작은지 확인
            if (leftChild < this.heap.length && 
                this.heap[leftChild][1] < this.heap[smallest][1]) {
                smallest = leftChild;
            }
            
            // 오른쪽 자식이 더 작은지 확인
            if (rightChild < this.heap.length && 
                this.heap[rightChild][1] < this.heap[smallest][1]) {
                smallest = rightChild;
            }
            
            // 더 작은 자식이 없다면 종료
            if (smallest === index) {
                break;
            }
            
            // 부모와 자식 교환
            [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];
            index = smallest;
        }
    }
}
```